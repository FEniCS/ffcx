
# This code conforms with the UFC specification version 2018.2.0.dev0
# and was automatically generated by FFCx version 0.11.0.dev0.
#
# This code was generated with the following options:
#
#  {'epsilon': 1e-14,
#   'language': 'numba',
#   'output_directory': '.',
#   'part': 'full',
#   'profile': False,
#   'scalar_type': 'float64',
#   'sum_factorization': False,
#   'table_atol': 1e-09,
#   'table_rtol': 1e-06,
#   'ufl_file': ['/Users/paul.kuehner/dev/ffcx/test/laplace.py'],
#   'verbosity': 30,
#   'visualise': False}

import numba
import numpy as np
import math

# ufcx enums
interval = 10
triangle = 20
quadrilateral = 30
tetrahedron = 40
hexahedron = 50
vertex = 60
prism = 70
pyramid = 80

cell = 0
exterior_facet = 1
interior_facet = 2

ufcx_basix_element = 0
ufcx_mixed_element = 1
ufcx_quadrature_element = 2
ufcx_basix_custom_element = 3


# Code for integral integral_a2f268a7bbb3d2df737ca07b130e11219a4f8086
import numba

def tabulate_tensor_integral_a2f268a7bbb3d2df737ca07b130e11219a4f8086(_A, _w, _c, _coordinate_dofs,
                                   _entity_local_index, _quadrature_permutation, void):

    A = numba.carray(_A, (9))
    w = numba.carray(_w, (0))
    c = numba.carray(_c, (4))
    coordinate_dofs = numba.carray(_coordinate_dofs, (1000))
    entity_local_index = numba.carray(_entity_local_index, (1000))
    quadrature_permutation = numba.carray(_quadrature_permutation, (1000))
        # Quadrature rules
    weights_083 = np.array([0.5], dtype=coordinate_dofs.dtype)
    # Precomputed values of basis functions and precomputations
    # FE* dimensions: [permutation][entities][points][dofs]
    FE0_C0_D01_Q083 = np.array([[[[-1.0, 0.0, 1.0]]]], dtype=coordinate_dofs.dtype)
    FE1_C0_D10_Q083 = np.array([[[[-1.0, 1.0, 0.0]]]], dtype=coordinate_dofs.dtype)
    # ------------------------ 
    # Section: Jacobian
    # Inputs: FE0_C0_D01_Q083, coordinate_dofs, FE1_C0_D10_Q083
    # Outputs: J0_c1, J0_c3, J0_c2, J0_c0
    J0_c0 = 0.0
    J0_c3 = 0.0
    J0_c1 = 0.0
    J0_c2 = 0.0
    for ic in range(0, 3):
        J0_c0 += coordinate_dofs[(ic) * 3] * FE1_C0_D10_Q083[0, 0, 0, ic]
        J0_c3 += coordinate_dofs[(ic) * 3 + 1] * FE0_C0_D01_Q083[0, 0, 0, ic]
        J0_c1 += coordinate_dofs[(ic) * 3] * FE0_C0_D01_Q083[0, 0, 0, ic]
        J0_c2 += coordinate_dofs[(ic) * 3 + 1] * FE1_C0_D10_Q083[0, 0, 0, ic]
        
    # ------------------------ 
    sp_083_0 = c[0] + c[3]
    sp_083_1 = J0_c0 * J0_c3
    sp_083_2 = J0_c1 * J0_c2
    sp_083_3 = -sp_083_2
    sp_083_4 = sp_083_1 + sp_083_3
    sp_083_5 = J0_c0 / sp_083_4
    sp_083_6 = -J0_c1
    sp_083_7 = sp_083_6 / sp_083_4
    sp_083_8 = sp_083_5 * sp_083_5
    sp_083_9 = sp_083_5 * sp_083_7
    sp_083_10 = sp_083_7 * sp_083_7
    sp_083_11 = J0_c3 / sp_083_4
    sp_083_12 = -J0_c2
    sp_083_13 = sp_083_12 / sp_083_4
    sp_083_14 = sp_083_13 * sp_083_13
    sp_083_15 = sp_083_11 * sp_083_13
    sp_083_16 = sp_083_11 * sp_083_11
    sp_083_17 = sp_083_8 + sp_083_14
    sp_083_18 = sp_083_9 + sp_083_15
    sp_083_19 = sp_083_16 + sp_083_10
    sp_083_20 = sp_083_0 * sp_083_17
    sp_083_21 = sp_083_0 * sp_083_18
    sp_083_22 = sp_083_0 * sp_083_19
    sp_083_23 = np.abs(sp_083_4)
    sp_083_24 = sp_083_20 * sp_083_23
    sp_083_25 = sp_083_21 * sp_083_23
    sp_083_26 = sp_083_22 * sp_083_23
    for iq in range(0, 1):
        # ------------------------ 
        # Section: Intermediates
        # Inputs: 
        # Outputs: fw0, fw1, fw2
        fw0 = 0
        fw1 = 0
        fw2 = 0
        fw0 = sp_083_26 * weights_083[iq]
        fw1 = sp_083_25 * weights_083[iq]
        fw2 = sp_083_24 * weights_083[iq]
        # ------------------------ 
        # ------------------------ 
        # Section: Tensor Computation
        # Inputs: fw2, fw0, FE1_C0_D10_Q083, fw1, FE0_C0_D01_Q083
        # Outputs: A
        # temp_0 = np.array([3], dtype=A.dtype)
        temp_0 = np.zeros(3, dtype=A.dtype)
        for j in range(0, 3):
            temp_0[j] = fw0 * FE1_C0_D10_Q083[0, 0, 0, j]
            
        # temp_1 = np.array([0], dtype=A.dtype)
        temp_1 = np.zeros(3, dtype=A.dtype)
        for j in range(0, 3):
            temp_1[j] = fw1 * FE0_C0_D01_Q083[0, 0, 0, j]
            
        # temp_2 = np.array([0], dtype=A.dtype)
        temp_2 = np.zeros(3, dtype=A.dtype)
        for j in range(0, 3):
            temp_2[j] = fw1 * FE1_C0_D10_Q083[0, 0, 0, j]
            
        # temp_3 = np.array([0], dtype=A.dtype)
        temp_3 = np.zeros(3, dtype=A.dtype)
        for j in range(0, 3):
            temp_3[j] = fw2 * FE0_C0_D01_Q083[0, 0, 0, j]
            
        for j in range(0, 3):
            for i in range(0, 3):
                A[3 * (i) + (j)] += FE1_C0_D10_Q083[0, 0, 0, i] * temp_0[j]
                A[3 * (i) + (j)] += FE1_C0_D10_Q083[0, 0, 0, i] * temp_1[j]
                A[3 * (i) + (j)] += FE0_C0_D01_Q083[0, 0, 0, i] * temp_2[j]
                A[3 * (i) + (j)] += FE0_C0_D01_Q083[0, 0, 0, i] * temp_3[j]
                
            
        # ------------------------ 
        
    

class integral_a2f268a7bbb3d2df737ca07b130e11219a4f8086(object):
    enabled_coefficients = []
    tabulate_tensor = tabulate_tensor_integral_a2f268a7bbb3d2df737ca07b130e11219a4f8086
    needs_facet_permutations = False
    coordinate_element = 16933917890882727400

# End of code for integral integral_a2f268a7bbb3d2df737ca07b130e11219a4f8086

# Code for form form_d599f40fd66a26e75317e6f9ae2b76df53aba2cd

class form_d599f40fd66a26e75317e6f9ae2b76df53aba2cd(object):

  signature = "427bcdcec006203ebb42559e15801e26779e7ce2f608ec02be89b550281415956f79607a4f6aae91dfaa53179dd2229ece5a149d6c5f82d33c28397879fade32"
  rank = 2
  num_coefficients = 0
  num_constants = 1
  original_coefficient_position = []

  coefficient_name_map = []
  constant_name_map = ["kappa"]

  form_integrals = [integral_a2f268a7bbb3d2df737ca07b130e11219a4f8086]
  form_integral_ids = [-1]
  form_integral_offsets = [0, 1, 1, 1]

form_laplace_a = form_d599f40fd66a26e75317e6f9ae2b76df53aba2cd

# Name: form_laplace_a
# End of code for form form_d599f40fd66a26e75317e6f9ae2b76df53aba2cd

